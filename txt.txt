seg fault for command $USER > [1]    64638 segmentation fault  ./lumumbash
echo $VAR > does not return anything
check exit function : seg faulting at line 	exit(exit_s); > Exception has occurred: Exception
EXC_BAD_ACCESS (code=1, address=0x20)



Error handling for dup2 and close calls: These system calls can fail, and you should check their return values. If they fail, you should handle the error appropriately.

Error handling for fork: You should check if fork fails and handle the error if it does.

Error handling for open: You should check if open fails and handle the error if it does.

Error handling for access: You should check if access fails and handle the error if it does.

Error handling for execve: You should check if execve fails and handle the error if it does.


// int	ft_append_separator(t_token_type type, char **line_ptr,
// 		t_token **token_list)
// {
// 	t_token	*token;
// 	int		length;

// 	length = (type == TOKEN_HEREDOC
// 			|| type == TOKEN_APPEND_OUTPUT_REDIRECTION) ? 2 : 1;
// 	token = ft_new_token(ft_substr(*line_ptr, 0, length), type);
// 	if (!token)
// 		return (0);
// 	*line_ptr += length;
// 	return (ft_token_list_add_back(token_list, token), 1);
// }

// int	ft_handle_separator(char **line_ptr, t_token **token_list)
// {
// 	int	length;

// 	length = 0;
// 	if (!ft_strncmp(*line_ptr, "<<", 2))
// 	{
// 		length = 2;
// 		return (ft_append_separator(TOKEN_HEREDOC, line_ptr, token_list) && 1);
// 	}
// 	else if (!ft_strncmp(*line_ptr, ">>", 2))
// 	{
// 		length = 2;
// 		return (ft_append_separator(TOKEN_APPEND_OUTPUT_REDIRECTION, line_ptr,
// 				token_list) && 1);
// 	}
// 	else if (!ft_strncmp(*line_ptr, "<", 1))
// 	{
// 		length = 1;
// 		return (ft_append_separator(TOKEN_INPUT_REDIRECTION, line_ptr,
// 				token_list) && 1);
// 	}
// 	else if (!ft_strncmp(*line_ptr, ">", 1))
// 	{
// 		length = 1;
// 		return (ft_append_separator(TOKEN_OUTPUT_REDIRECTION, line_ptr,
// 				token_list) && 1);
// 	}
// 	else
// 	{
// 		length = 1;
// 		return (ft_append_separator(TOKEN_PIPE, line_ptr, token_list) && 1);
// 	}
// 	*line_ptr += length;
// }

// int	ft_append_word(char **line_ptr, t_token **token_list)
// {
// 	int		i;
// 	char	*line;
// 	int		in_quotes;
// 	char	*word;
// 	int		j;

// 	i = 0;
// 	line = *line_ptr;
// 	in_quotes = 0;
// 	word = malloc(ft_strlen(line) + 1);
// 	if (!word)
// 		return (0);
// 	j = 0;
// 	while (line[i])
// 	{
// 		if (line[i] == '\\' && line[i + 1])
// 		{
// 			word[j++] = line[++i];
// 		}
// 		else if (line[i] == '"' || line[i] == '\'')
// 		{
// 			if (in_quotes)
// 			{
// 				if (in_quotes == line[i])
// 				{
// 					in_quotes = 0;
// 				}
// 			}
// 			else
// 			{
// 				in_quotes = line[i];
// 			}
// 			word[j++] = line[i];
// 		}
// 		else if (!in_quotes && (line[i] == '<' || line[i] == '>'
// 				|| line[i] == '|' || line[i] == ';' || line[i] == ' '))
// 		{
// 			break ;
// 		}
// 		else
// 		{
// 			word[j++] = line[i];
// 		}
// 		i++;
// 	}
// 	word[j] = '\0';
// 	if (!ft_token_list_add_back(token_list, ft_new_token(word, TOKEN_WORD)))
// 	{
// 		free(word);
// 		return (0);
// 	}
// 	*line_ptr += i;
// 	return (1);
// }

// t_token	*ft_tokenization_handler(char *line)
// {
// 	int		error;
// 	t_token	*token_list;

// 	error = 0;
// 	token_list = NULL;
// 	while (*line)
// 	{
// 		if (error)
// 		{
// 			ft_clear_token_list(&token_list);
// 			return (NULL);
// 		}
// 		if (ft_isspace(*line))
// 		{
// 			ft_skip_spaces(&line);
// 		}
// 		else if (!ft_strncmp(line, "<", 1) || !ft_strncmp(line, ">", 1)
// 			|| !ft_strncmp(line, "|", 1))
// 		{
// 			error = !ft_handle_separator(&line, &token_list);
// 		}
// 		else
// 		{
// 			error = !ft_append_word(&line, &token_list);
// 		}
// 	}
// 	if (error)
// 	{
// 		ft_clear_token_list(&token_list);
// 		return (NULL);
// 	}
// 	return (token_list);
// }

// int ft_append_separator(t_token_type type,char **line_ptr,t_token **token_list)
// {
//     t_token *token;
//     int length;
//     if (type == TOKEN_HEREDOC || type == TOKEN_APPEND_OUTPUT_REDIRECTION)
//     {
//         length = 2;
//     }
//     else
//     {
//         length = 1;
//     }
//     token = ft_new_token(ft_substr(*line_ptr, 0, length), type);
//     if (!token)
//     {
//         return (0);
//     }
//     *line_ptr += length;
//     ft_token_list_add_back(token_list, token);
//     return (1);
// }



In your ft_modif_env_var function, you're calling ft_free_double_d(minishell->environ) before assigning minishell->environ to new_environ. This is correct, as you're freeing the old environment before assigning the new one.

However, in your ft_add_env_var function, you're also calling ft_free_double_d(minishell->environ) before assigning minishell->environ to str. This is also correct in isolation.

The problem arises when ft_add_env_var calls ft_modif_env_var, because ft_modif_env_var also frees minishell->environ. So if ft_add_env_var calls ft_modif_env_var, minishell->environ will be freed twice, which is likely the cause of your segfault.

To fix this, you should remove the call to ft_free_double_d(minishell->environ) from ft_add_env_var. The ft_modif_env_var function should be responsible for freeing minishell->environ, and ft_add_env_var should not free it again.



echo "hi" | echo command IN MY TERMINAL DOES NOT PRINT ANYTHING. PLEASE FIX MY CODE:
exec_simple_cmd: Command - echo
is_builtin: Checking command - echo
is_builtin: Detected as builtin command
exec_simple_cmd: Detected builtin command
exec_builtin: Executing command - echo
THE CODE:
bool	ft_current_token_is_op(t_minishell *minishell)
{
	t_token_type	type;

	if (!minishell->current_token)
		return (false);
	type = minishell->current_token->type;
	if (type == TOKEN_PIPE)
		return (true);
	return (false);
}
t_node	*ft_term(t_minishell *minishell)
{
	if (minishell->parse_error.type)
		return (NULL);
	if (ft_current_token_is_op(minishell))
	{
		ft_set_parse_error(SYNTAX_ERROR);
		return (NULL);
	}
	else
	{
		return (ft_get_simple_cmd(minishell));
	}
}
t_node	*ft_get_simple_cmd(t_minishell *minishell)
{
	t_node	*node;
	char	**split_args;
	int		i;

	if (minishell->parse_error.type)
		return (NULL);
	node = ft_create_node();
	if (!node)
		return (NULL);
	split_args = ft_allocate_split_args();
	if (!split_args)
	{
		free(node);
		return (NULL);
	}
	node->split_args = split_args;
	i = 0;
	ft_process_tokens(minishell, node, &i);
	node->split_args[i] = NULL;
	return (node);
}
t_node	*ft_expression(t_minishell *minishell)
{
	t_node			*left;
	t_node			*right;
	t_token_type	op;

	if (minishell->parse_error.type || !minishell->current_token)
		return (NULL);
	left = ft_term(minishell);
	if (!left)
		return (NULL);
	while (ft_current_token_is_op(minishell))
	{
		op = minishell->current_token->type;
		ft_get_next_token(minishell);
		if (!minishell->current_token)
			return (ft_set_parse_error(SYNTAX_ERROR), left);
		right = ft_expression(minishell);
		if (!right)
			return (left);
		left = ft_combine(op, left, right, minishell);
		if (!left)
			return (ft_clear_ast(&left, minishell), ft_clear_ast(&right,
					minishell), NULL);
	}
	return (left);
}
void	ft_get_next_token(t_minishell *minishell)
{
	minishell->current_token = minishell->current_token->next;
}

t_node	*ft_combine(t_token_type op, t_node *left, t_node *right,
		t_minishell *minishell)
{
	t_node	*node;

	if (minishell->parse_error.type)
		return (NULL);
	node = ft_new_node(ft_get_node_type(op));
	if (!node)
		return (ft_set_parse_error(MALLOC_ERROR), NULL);
	node->left = left;
	node->right = right;
	return (node);
}
int	ft_exec_node(t_node *tree, bool piped, t_minishell *minishell)
{
	if (!tree)
		return (1);
	if (tree->type == NODE_PIPE)
		return (ft_exec_pipeline(tree, minishell));
	else
		return (ft_exec_simple_cmd(tree, piped, minishell));
	return (GENERAL);
}
static int	ft_exec_pipeline(t_node *tree, t_minishell *minishell)
{
	int	status;
	int	pfds[2];
	int	pid_left;
	int	pid_right;

	pipe(pfds);
	pid_left = fork();
	if (pid_left == 0)
	{
		child_process_left(tree, pfds, minishell);
	}
	pid_right = fork();
	if (pid_right == 0)
	{
		child_process_right(tree, pfds, minishell);
	}
	close(pfds[0]);
	close(pfds[1]);
	waitpid(pid_left, &status, 0);
	waitpid(pid_right, &status, 0);
	return (ft_get_exit_status(status));
}
int	ft_get_exit_status(int status)
{
	if (WIFSIGNALED(status))
		return (128 + WTERMSIG(status));
	return (WEXITSTATUS(status));
}
int	ft_exec_node(t_node *tree, bool piped, t_minishell *minishell)
{
	if (!tree)
		return (1);
	if (tree->type == NODE_PIPE)
		return (ft_exec_pipeline(tree, minishell));
	else
		return (ft_exec_simple_cmd(tree, piped, minishell));
	return (GENERAL);
}
static void	child_process_left(t_node *tree, int *pfds, t_minishell *minishell)
{
	close(pfds[0]);
	dup2(pfds[1], STDOUT_FILENO);
	close(pfds[1]);
	ft_exec_node(tree->left, true, minishell);
	exit(EXIT_FAILURE);
}
static void	child_process_right(t_node *tree, int *pfds, t_minishell *minishell)
{
	close(pfds[1]);
	dup2(pfds[0], STDIN_FILENO);
	close(pfds[0]);
	ft_exec_node(tree->right, true, minishell);
	exit(EXIT_FAILURE);
}



tests for pipe??
echo "Hello, world!" | echo
echo "TEST_VAR=Hello, world!" | export && echo $TEST_VAR
export TEST_VAR="Hello, world!" && echo "TEST_VAR" | unset && echo $TEST_VAR
echo "/" | pwd